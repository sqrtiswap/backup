#!/bin/sh

_fail="\033[31m"
_good="\033[32m"
_rset="\033[0m"

set -e

command -v rsync > /dev/null \
	&& RSYNC='rsync' \
	|| RSYNC='openrsync'
command -v doas > /dev/null \
	&& _doas=doas \
	|| _doas=sudo

_resourcedir="$HOME"/sources/backup

backup() {
	[ -n "$2" ] && _mntpoint="$2" || exit 1
	dirlist="${_resourcedir}"/list-backup.txt
	nr=$(grep -c '' "$dirlist")
	i=0

	while IFS= read -r d ; do
		i=$((i+1))
		"$RSYNC" -av --delete "$HOME/$d" "${_mntpoint}/" \
			&& printf "${_good}%s${_rset}\n\n" "---> Synced $i/${nr}" \
			|| exit 1
	done < "$dirlist"
	[ -f "$HOME"/mbox ] && cp -vf "$HOME"/mbox "${_mntpoint}"
}

check_bitrot() {
	checklist="${_resourcedir}"/list-bitrot.txt
	nr=$(grep -c '' "$checklist")
	i=0

	while IFS= read -r d ; do
		i=$((i+1))
		cd "$HOME"/"$d" && bitrot \
			&& printf "${_good}%s${_rset}\n\n" "---> checked bitrot $i/${nr} ($HOME/$d)" \
			|| exit 1
	done < "$checklist"
}

collect_config() {
	# collect stuff in ~/.config/
	printf "%s\n" "---> Start collecting configurations:"
	_configdir="${_dotdir}"/configurations
	mkdir -p "${_configdir}" \
		&& printf "${_good}%s${_rset}\n" "Created ${_configdir}" \
		|| exit 1

	mkdir -p "${_configdir}"/.config || exit 1
	configlist="${_resourcedir}"/list-config.txt
	nr=$(grep -c '' "$configlist")
	i=0

	while IFS= read -r c ; do
		if [ -e "$HOME"/.config/"$c" ] ; then
			i=$((i+1))
			cp -R "$c" "${_configdir}"/.config \
				&& printf "${_good}%s${_rset}\n" "collected $i/${nr} ($HOME/.config/$c)" \
				|| exit 1
		else
			printf "${_fail}%s${_rset}\n" "$c does not exist."
		fi
	done < "$configlist"

	# collect stuff in ~/
	homelist="${_resourcedir}"/list-home.txt
	nr=$(grep -c '' "$homelist")
	i=0

	while IFS= read -r h ; do
		if [ -e "$HOME"/"$h" ] ; then
			i=$((i+1))
			cp -R "$c" "${_configdir}" \
				&& printf "${_good}%s${_rset}\n" "collected $i/${nr} ($HOME/$h)" \
				|| exit 1
		else
			printf "${_fail}%s${_rset}\n" "$c does not exist."
		fi
	done < "$homelist"

	# collect just the config from ~/.ssh/
	mkdir -p "${_configdir}"/.ssh && cp "$HOME"/.ssh/config "${_configdir}"/.ssh/config
}

collect_privconfig() {
	if "${_resourcedir}"/collect_privconfig ; then
		printf "${_good}[3/5] ----- Collected privileged configurations.${_rset}\n\n"
	else
		printf "${_fail}[3/5] ----- Collecting privileged configurations failed.${_rset}\n\n"
		exit 1
	fi
}

collect_installs() {
	printf "%s\n" "---> Start collecting installed packages:"
	_installdir="${_dotdir}"/installed_packages
	mkdir -p "${_installdir}" \
		&& printf "${_good}%s${_rset}\n" "Created ${_installdir}" \
		|| exit 1

	if [ "$(uname -s)" = "OpenBSD" ] ; then
		pkg_info -tz >> "${_installdir}"/openbsd_pkgs.txt \
			&& printf "${_good}%s${_rset}\n" "collected OpenBSD packages" \
			|| exit 1
	elif [ "$(awk -F "(\"| )" 'NR == 1 { print $2 }' /etc/os-release)" = "Fedora" ] ; then
		dnf history userinstalled >> "${_installdir}"/fedora_pkgs.txt \
			&& printf "${_good}%s${_rset}\n" "collected Fedora packages" \
			|| exit 1
		flatpak list --app >> "${_installdir}"/flatpaks.txt \
			&& printf "${_good}%s${_rset}\n" "collected Flatpaks packages" \
			|| exit 1
	else
		printf "${_fail}%s${_rset}\n" "OS is unknown. Aborting..." && exit 1
	fi
}

collect_data() {
	if "${_resourcedir}"/collect_data ; then
		printf "${_good}[5/5] ----- Collected data.${_rset}\n\n"
	else
		printf "${_fail}[5/5] ----- Collecting data failed.${_rset}\n\n"
		exit 1
	fi
}

finish_dotfiles() {
	cd "${_dotdir}" && du -d1 | sort -h
}

prepare_dotfiles() {
	_dotdir="$HOME"/dotfiles/"$(date +%F)"
	if [ -d "${_dotdir}" ] ; then
		echo "${_dotdir} already exists. Do some clean-up!"
		exit 1
	else
		mkdir -p "${_dotdir}"
		printf "${_good}%s${_rset}\n" "Created ${_dotdir}"
	fi
}

usage() { cat << USAGE
${0##*/} - a selection of scripts for reliable backups
usage: ${0##*/}	all [dir] -> backup all directories to [dir]
		bitrot    -> check for bitrot in selected directories
		dotfiles  -> collect dotfiles"
USAGE
	exit 1
}

set +e

case $1 in
all)
	backup "$@"
	;;
bitrot)
	check_bitrot
	;;
dotfiles)
	prepare_dotfiles
	collect_config
	collect_data
	collect_privconfig
	collect_installs
	finish_dotfiles
	;;
*)
	usage
	;;
esac
