#!/bin/sh

_fail="\033[31m" # red
_good="\033[32m" # green
_rset="\033[0m"  # reset

set -e

command -v rsync > /dev/null \
	&& RSYNC='rsync' \
	|| RSYNC='openrsync'
command -v doas > /dev/null \
	&& _doas=doas \
	|| _doas=sudo

_resourcedir="$HOME"/sources/backup
_datadir="$HOME"/sources/Dotfiles/Data

backup() {
	# todo(1) report
	nr_of_reports="$(grep -c "$(date +%F)" "$TODODIR"/report.txt)"
	[ "${nr_of_reports}" -lt 1 ] && todo -q report

	# backup with RSYNC
	[ -n "$2" ] && _mntpoint="$2" || exit 1
	dirlist="${_resourcedir}"/list-backup.txt
	nr=$(($(grep -c '' "$dirlist")+1))
	i=0
	while IFS= read -r d ; do
		i=$((i+1))
		"$RSYNC" -av --delete --exclude-from="${_resourcedir}"/list-exclude.txt "$HOME/$d" "${_mntpoint}/" \
			&& printf "${_good}%s${_rset}\n\n" "---> Synced $i/${nr} ($d)" \
			|| exit 1
	done < "$dirlist"

	# backup ~/mbox if it exists
	if [ -f "$HOME"/mbox ] ; then
		cp -vf "$HOME"/mbox "${_mntpoint}" \
			&& printf "${_good}%s${_rset}\n\n" "---> Synced ${nr}/${nr} (mbox)" \
			|| exit 1
	else
		printf "%s does not exist. Nothing to backup.\n" "$HOME/mbox" \
			&& printf "${_good}%s${_rset}\n\n" "---> Synced ${nr}/${nr} (mbox)" \
			|| exit 1
	fi
}

backup_restic() {
	# backup with restic(1)
	[ -n "$2" ] && _mntpoint="$2" || exit 1
	restic backup \
		--repo="${_mntpoint}" \
		--verbose \
		--exclude-file="${_resourcedir}"/list-exclude.txt \
		--files-from-verbatim "${_resourcedir}"/restic-include.txt
}

check_bitrot() {
	# use bitrot(1) to detect errors in important directories
	checklist="${_resourcedir}"/list-bitrot.txt
	nr=$(grep -c '' "$checklist")
	i=0
	while IFS= read -r d ; do
		i=$((i+1))
		cd "$HOME"/"$d" && bitrot \
			&& printf "${_good}%s${_rset}\n\n" "---> checked bitrot $i/${nr} ($HOME/$d)" \
			|| exit 1
	done < "$checklist"
}

checkout_restic() {
	_repo="$2"
	_snapshot="$3"
	_target="$4"
	_path="$5"
	restic -r "${_repo}" restore "${_snapshot}" --target "${_target}" --include "${_path}"
}

collect_special() {
	# dump notmuch database
	notmuch dump --output="${_datadir}"/notmuch-dump.txt
}

collect_installs() {
	printf "%s\n" "---> Start collecting installed packages:"
	OS=$(uname -s)
	if [ "${OS}" = "OpenBSD" ] ; then
		pkg_info -tz >> "${_datadir}"/openbsd_pkgs.txt \
			&& printf "${_good}%s${_rset}\n" "collected OpenBSD packages" \
			|| exit 1
	elif [ "${OS}" = "Linux" ] ; then
		if [ "$(awk -F "(\"| )" 'NR == 1 { print $2 }' /etc/os-release)" = "Fedora" ] ; then
			dnf history userinstalled >> "${_datadir}"/fedora_pkgs.txt \
				&& printf "${_good}%s${_rset}\n" "collected Fedora packages" \
				|| exit 1
			flatpak list --app >> "${_datadir}"/flatpaks.txt \
				&& printf "${_good}%s${_rset}\n" "collected Flatpaks packages" \
				|| exit 1
		fi
	else
		printf "${_fail}%s${_rset}\n" "OS is unknown. No packages collected."
	fi
	if command -v brew > /dev/null ; then
		brew bundle dump --force --file="${_datadir}"/Brewfile \
			&& printf "${_good}%s${_rset}\n" "Brewfile created" \
			|| exit 1
	fi
}

usage() { cat << USAGE
${0##*/} - a selection of scripts for reliable backups
usage: ${0##*/}	all [dir]                 -> backup all directories to [dir]
		bitrot                    -> check for bitrot in selected directories
		checkout_restic [options] -> Checkout restic snapshot data with variety of options (currently not documented)
		prep                      -> prepare for backing up
		restic [repo]             -> backup to a restic(1) [repo]
USAGE
	exit 1
}

set +e

case $1 in
all)
	backup "$@"
	;;
bitrot)
	check_bitrot
	;;
checkout)
	checkout_restic "$@"
	;;
prep)
	collect_special
	check_bitrot
	collect_installs
	;;
restic)
	backup_restic "$@"
	;;
*)
	usage
	;;
esac
