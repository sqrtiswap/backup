#!/bin/sh

_fail="\033[31m" # red
_good="\033[32m" # green
_rset="\033[0m"  # reset

set -e

command -v rsync > /dev/null \
	&& RSYNC='rsync' \
	|| RSYNC='openrsync'
command -v doas > /dev/null \
	&& _doas=doas \
	|| _doas=sudo

_resourcedir="$HOME"/sources/backup

backup() {
	# todo(1) report
	nr_of_reports="$(grep -c "$(date +%F)" "$TODODIR"/report.txt)"
	[ "${nr_of_reports}" -lt 1 ] && todo -q report

	# backup with RSYNC
	[ -n "$2" ] && _mntpoint="$2" || exit 1
	dirlist="${_resourcedir}"/list-backup.txt
	nr=$(($(grep -c '' "$dirlist")+1))
	i=0
	while IFS= read -r d ; do
		i=$((i+1))
		"$RSYNC" -av --delete --exclude-from="${_resourcedir}"/list-exclude.txt "$HOME/$d" "${_mntpoint}/" \
			&& printf "${_good}%s${_rset}\n\n" "---> Synced $i/${nr} ($d)" \
			|| exit 1
	done < "$dirlist"

	# backup ~/mbox if it exists
	if [ -f "$HOME"/mbox ] ; then
		cp -vf "$HOME"/mbox "${_mntpoint}" \
			&& printf "${_good}%s${_rset}\n\n" "---> Synced ${nr}/${nr} (mbox)" \
			|| exit 1
	else
		printf "%s does not exist. Nothing to backup.\n" "$HOME/mbox" \
			&& printf "${_good}%s${_rset}\n\n" "---> Synced ${nr}/${nr} (mbox)" \
			|| exit 1
	fi
}

backup_restic() {
	# backup with restic(1)
	[ -n "$2" ] && _mntpoint="$2" || exit 1
	restic backup \
		--repo="${_mntpoint}" \
		--verbose \
		--exclude-file="${_resourcedir}"/list-exclude.txt \
		--files-from-verbatim "${_resourcedir}"/restic-include.txt
}

check_bitrot() {
	# use bitrot(1) to detect errors in important directories
	checklist="${_resourcedir}"/list-bitrot.txt
	nr=$(grep -c '' "$checklist")
	i=0
	while IFS= read -r d ; do
		i=$((i+1))
		cd "$HOME"/"$d" && bitrot \
			&& printf "${_good}%s${_rset}\n\n" "---> checked bitrot $i/${nr} ($HOME/$d)" \
			|| exit 1
	done < "$checklist"
}

collect_config() {
	# collect stuff in ~/.config/
	_configdir="${_dotdir}"/.config
	mkdir -p "${_configdir}" || exit 1
	configlist="${_resourcedir}"/list-config.txt
	nr=$(grep -c '' "$configlist")
	i=0

	while IFS= read -r c ; do
		if [ -e "$HOME"/.config/"$c" ] ; then
			i=$((i+1))
			cp -R "$HOME"/.config/"$c" "${_configdir}" \
				&& printf "${_good}%s${_rset}\n" "collected $i/${nr} ($HOME/.config/$c)" \
				|| exit 1
		else
			printf "${_fail}%s${_rset}\n" "$c does not exist."
		fi
	done < "$configlist"
}

collect_home() {
	# collect stuff in ~/
	_homedir="${_dotdir}"/home
	mkdir -p "${_homedir}" || exit 1
	homelist="${_resourcedir}"/list-home.txt
	nr=$(grep -c '' "$homelist")
	i=0

	while IFS= read -r h ; do
		if [ -e "$HOME"/"$h" ] ; then
			i=$((i+1))
			cp -R "$HOME"/"$h" "${_homedir}" \
				&& printf "${_good}%s${_rset}\n" "collected $i/${nr} ($HOME/$h)" \
				|| exit 1
		else
			printf "${_fail}%s${_rset}\n" "$h does not exist."
		fi
	done < "$homelist"
}

collect_special() {
	# collect just the config from ~/.ssh/
	mkdir -p "${_homedir}"/.ssh && cp "$HOME"/.ssh/config "${_homedir}"/.ssh/config

	# dump notmuch database
	notmuch dump --output="${_homedir}"/notmuch-dump.txt
}

collect_gpg() {
	# collect just the configs from ~/.gnupg/
	_gpgdir="${_homedir}"/.gpg
	mkdir -p "${_gpgdir}" || exit 1
	gpglist="${_resourcedir}"/list-gpg.txt
	nr=$(grep -c '' "$gpglist")
	i=0

	while IFS= read -r g ; do
		if [ -e "$HOME"/.gnupg/"$g" ] ; then
			i=$((i+1))
			cp "$HOME"/.gnupg/"$g" "${_gpgdir}" \
				&& printf "${_good}%s${_rset}\n" "collected $i/${nr} ($HOME/.gnupg/$g)" \
				|| exit 1
		else
			printf "${_fail}%s${_rset}\n" "$g does not exist."
		fi
	done < "$gpglist"
}

collect_privconfig() {
	printf "%s\n" "---> Start collecting privileged configurations:"
	_privdir="${_dotdir}"/PRIVILEGED

	mkdir -p "${_privdir}"/etc/ || exit 1
	privlist="${_resourcedir}"/list-privconfig-etc.txt
	nr=$(grep -c '' "$privlist")
	i=0
	while IFS= read -r p ; do
		if [ -e /etc/"$p" ] ; then
			i=$((i+1))
			"${_doas}" cp /etc/"$p" "${_privdir}"/etc/ \
				&& printf "${_good}%s${_rset}\n" "collected $i/${nr} (/etc/$p)" \
				|| exit 1
		else
			printf "${_fail}%s${_rset}\n" "$p does not exist."
		fi
	done < "$privlist"

	if [ -e /etc/X11/xenodm ] ; then
		mkdir -p "${_privdir}"/etc/X11/xenodm/ || exit 1
		xenocaralist="${_resourcedir}"/list-privconfig-etc.txt
		nr=$(grep -c '' "$xenocaralist")
		i=0
		while IFS= read -r x ; do
			if [ -e /etc/X11/xenodm/"$x" ] ; then
				i=$((i+1))
				"${_doas}" cp /etc/X11/xenodm/"$x" "${_privdir}"/etc/X11/xenodm \
					&& printf "${_good}%s${_rset}\n" "collected $i/${nr} (/etc/X11/xenodm/$x)" \
					|| exit 1
			else
				printf "${_fail}%s${_rset}\n" "$x does not exist."
			fi
		done < "$xenocaralist"
	fi

	"${_doas}" chown -R "$USER:$USER" "${_privdir}" \
		&& printf "${_good}%s${_rset}\n" "changed ownership of privileged config" \
		|| exit 1
}

collect_installs() {
	printf "%s\n" "---> Start collecting installed packages:"
	_installdir="${_dotdir}"/installed_packages
	mkdir -p "${_installdir}" \
		&& printf "${_good}%s${_rset}\n" "Created ${_installdir}" \
		|| exit 1

	if [ "$(uname -s)" = "OpenBSD" ] ; then
		pkg_info -tz >> "${_installdir}"/openbsd_pkgs.txt \
			&& printf "${_good}%s${_rset}\n" "collected OpenBSD packages" \
			|| exit 1
	elif [ "$(awk -F "(\"| )" 'NR == 1 { print $2 }' /etc/os-release)" = "Fedora" ] ; then
		dnf history userinstalled >> "${_installdir}"/fedora_pkgs.txt \
			&& printf "${_good}%s${_rset}\n" "collected Fedora packages" \
			|| exit 1
		flatpak list --app >> "${_installdir}"/flatpaks.txt \
			&& printf "${_good}%s${_rset}\n" "collected Flatpaks packages" \
			|| exit 1
	else
		printf "${_fail}%s${_rset}\n" "OS is unknown. No packages collected."
	fi
}

finish_dotfiles() {
	cd "$HOME"/dotfiles && du -h -d1 | sort -h
}

prepare_dotfiles() {
	_dotdir="$HOME"/dotfiles/"$(date +%F)"
	if [ -d "${_dotdir}" ] ; then
		echo "${_dotdir} already exists. Do some clean-up!"
		exit 1
	else
		mkdir -p "${_dotdir}"
		printf "${_good}%s${_rset}\n" "Created ${_dotdir}"
	fi
	mv "$HOME"/Downloads/bookmarks.html "${_dotdir}"/torbookmarks.html
	mv "$HOME"/Downloads/bookmarks_"$(date +%d_%m_%Y)".html "${_dotdir}"/chromebookmarks.html
}

usage() { cat << USAGE
${0##*/} - a selection of scripts for reliable backups
usage: ${0##*/}	all [dir]     -> backup all directories to [dir]
		bitrot        -> check for bitrot in selected directories
		dotfiles      -> collect dotfiles"
		restic [repo] -> backup to a restic(1) [repo]
USAGE
	exit 1
}

set +e

case $1 in
all)
	backup "$@"
	;;
bitrot)
	check_bitrot
	;;
dotfiles)
	prepare_dotfiles
	collect_config
	collect_home
	collect_special
	collect_gpg
	collect_privconfig
	collect_installs
	finish_dotfiles
	;;
restic)
	backup_restic "$@"
	;;
*)
	usage
	;;
esac
